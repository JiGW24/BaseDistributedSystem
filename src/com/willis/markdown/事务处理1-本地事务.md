# 事务处理 (一)

事务处理是构建分布式系统过程中不可忽略的部分，在谈分布式事务之前，先对**事务**的重要理论知识进行回顾。

阅读下文前，务必已熟悉何为**ACID特性**，数据库基本概念等，这里不做赘述。
![事务特性](../pictures/ACID.png)

### 本地事务

本地事务是指仅操作单一事务资源的、不需要全局事务管理器进行协调的事务。


#### 如果实现原子性和持久性

1. Commit Logging
   
    提交日志的方式，即以仅进行顺序追加的文件写入的形式先记录到磁盘中。

2. Shadow Paging

#### 实现隔离性

现代数据库提供了三种锁：
1. 写锁，即排它锁。只有持有写锁的事务才可以对数据进行写操作。这是其他事务不能写入数据，也不能施加读锁。
2. 读锁，即共享锁。多个事务可以对同一个数据施加读锁，数据被加上读锁后就无法再施加写锁。对于持有读锁的事务，如果当前只有它一个事务有读锁，可允许直接将其升级为写锁。
3. 范围锁。对于某一个范围直接加排它锁，这个范围内的数据不能直接被写入。

##### 隔离级别
隔离程度越高，并发访问时的吞吐量就会越低

- 可串行化

- 可重复读
    
    这是MySQL/InnoDB的默认隔离级别，可重复读对事务涉及的数据施加读锁和写锁且一直到事务结束，但不加范围锁。相较于可串行话，存在**幻读**问题，在事务的执行过程中，查询相同范围的数据获取到不同的结果
```sql
select count(1) from t_a where column_b < 10 #事务1
insert into t_a(column_b) values ('ccc') #事务2
select count(1) from t_a where column_b < 10 #事务1
```
- 读已提交
    
    对事务涉及的写锁会一直持续要事务结束，但加的读锁在执行完会马上释放。相较于可重复读弱化的地方在于不可重复读问题，对同一行数据相同的查询得到了不同的结果。因为这个过程缺乏了读锁，不能禁止读取过的数据发生变化
```sql
select * from t_a where id =  10 #事务1
update t_a set d = 111 where id = 10 #事务2
select * from t_a where id =  10 #事务1
```

- 读未提交
    
    对事务涉及的数据加写锁，读锁完全不加。会出现脏读问题，指在事务执行过程中，一个事务读取到了另一个事务未提交的数据。这里需要注意写锁的定义，写锁禁止其他事务施加读锁，但是不代表不允许其他事务读取事务。
```sql
select * from t_a where id =  10 #事务1
update t_a set d = 111 where id = 10 #事务2
select * from t_a where id =  10 #事务1
rollback; #事务2
```

